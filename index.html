<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JVM加载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/16/JVM加载/" class="article-date">
  <time datetime="2019-10-16T09:11:40.000Z" itemprop="datePublished">2019-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/16/JVM加载/">JVM加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##加载</p>
<p>###简介</p>
<p>通过类全限定名binary name 来定义二进制字节流，把这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成java.lang.Class对象是方法区这个类的各种数据的访问入口。</p>
<h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>####类加载器</p>
<p>双亲委托模型下的加载器：bootstrap 启动类加载器，ext 扩展类加载器，系统/应用类加载器，自定义类加载器</p>
<p><strong>启动类加载器</strong></p>
<p>启动类加载器是负责加载rt.jar和其他类加载器的加载器 即一些重要class对象，而启动类加载器是虚拟机自带的一段c++代码，所以它不是java类，他在虚拟机启动时就有了不需要加载器去加载。所以一个类getClassLoader()返回null 则这个类是由启动类加载器去加载的。负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 <code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 <code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。</p>
<p><strong>扩展类加载器</strong></p>
<p><code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 <code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</p>
<p><strong>应用类加载器</strong></p>
<p><code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p><strong>自定义类加载器</strong></p>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<ul>
<li>1、在执行非置信代码之前，自动验证数字签名。</li>
<li>2、动态地创建符合用户特定需要的定制化构建类。</li>
<li>3、从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<p><strong>JVM类加载机制</strong></p>
<ul>
<li><p>全部负责：当一个类加载器负责加载某个class类时，该class类所有依赖和引用其他class类也将由该类加载器负责载入，除非显示使用另一个类加载器（SPI）但是注意命名空间的问题</p>
</li>
<li><p>父类委托：当一个类加载负责加载某个class类时，先去判断有没有加载过这个类，没有的话委托父类去加载这个类，以此类推到启动类加载器，然后由自身去加载，这样更安全让重要的类首先会被启动，扩展，系统等加载器加载而不是自定义加载器。</p>
</li>
</ul>
<p><strong>类的加载方式</strong></p>
<ul>
<li><p>命令行启动应用时进行加载</p>
</li>
<li><p>通过<code>Class.forName()</code>方法动态加载</p>
</li>
<li><p>通过<code>ClassLoader.loadClass()</code>方法动态加载</p>
</li>
</ul>
<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ul>
<li><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了<code>newInstance()</code>方法采用调用构造函数，创建类的对象 。</li>
</ul>
<p>ClassLoader源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双亲委派模型的意义</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
<p><strong>命名空间</strong></p>
<ul>
<li><p>子加载器加载的类可以访问父加载器加载的类，而父加载器加载的类访问不了子加载器加载的类</p>
</li>
<li><p>命名空间是由 当前加载器和其父加载器构成的，其中的类不能重复</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">    MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader2"</span>);</span><br><span class="line">    loader1.setPath(<span class="string">"/Users/yujia/Desktop/"</span>);</span><br><span class="line">    loader2.setPath(<span class="string">"/Users/yujia/Desktop/"</span>);</span><br><span class="line">    Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.zyj.module.Person"</span>);</span><br><span class="line">    Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.zyj.module.Person"</span>);</span><br><span class="line">    System.out.println(clazz1 == clazz2);</span><br><span class="line">    Object object1 = clazz1.newInstance();</span><br><span class="line">    Object object2 = clazz2.newInstance();</span><br><span class="line">    Method method = clazz1.getMethod(<span class="string">"setPerson"</span>, Object.class);</span><br><span class="line">    method.invoke(object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让loader1和loader2去自己去加载Person而不是父类启动类加载器（class路径删除Person.class 仅放在桌面也就是这个MyClassLoader的可以知道的范围下） 通过<code>method.invoke(object1, object2)</code>报错，内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at com.zyj.<span class="keyword">module</span>.Test10.main(Test10.java:<span class="number">39</span>)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.zyj.<span class="keyword">module</span>.Person cannot be cast to com.zyj.<span class="keyword">module</span>.Person</span><br><span class="line">	at com.zyj.<span class="keyword">module</span>.Person.setPerson(Person.java:<span class="number">14</span>)</span><br><span class="line">	... <span class="number">5</span> more</span><br></pre></td></tr></table></figure>

<p><code>Caused by: java.lang.ClassCastException: com.zyj.module.Person cannot be cast to com.zyj.module.Person</code> 这就是不同的类加载器命名空间中的类相互不认识的例子</p>
<p><strong>双亲委托模型的父子关系</strong></p>
<p>是引用关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(loader1, <span class="string">"loader2"</span>);</span><br></pre></td></tr></table></figure>

<p>loader1和loader2同一个自定义类，但是loader2的构造器让loader1成为loader2的父加载器。</p>
<p><strong>上下文类加载器</strong></p>
<p>由于类加载器的特点：全部负责即负责该类的加载的类加载器也会负责类的引用的class的加载。而SPI这种情况 接口类属于由启动类加载而implement是由依赖加进去也就是系统类加载器加载，而父加载器不认识子加载器的类（命名空间）会报错，而上下文加载器就是而父加载器不认识子加载器或者没有父子关系的加载器的类相互不认识的问题。</p>
<p>当前类加载器 Current ClassLoader，线程上下文加载器就是当前线程的Current ClassLoader</p>
<p>如果没有通过<code>Thread.currentThread().getContextClassLoader()</code> 方法进行设置， 线程将继承父线程的上下文加载器，而启动类的上下文contextClassLoader是系统类加载器（满足SPI实现去来自不同的jar包 厂商提共的）</p>
<p><strong>上下文类加载器的总结</strong>：在双亲委托模型下，类加载从下至上的，下层的类加载器会委托上层的类加载器去加载，但在spi来说，有些接口时java核心库所提供的，而java核心库是用启动类加载器所提供的，而这些接口的实现去来自不同的jar包 厂商提共的， java的启动类加载器不会加载其他来源的jar包， 这些传统的双清委托模型无法满足spi要求，而这些可以同给当前线程设置上下文类加载器就可以由上下文类加载器来实现对于接口实现类的加载。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/16/JVM加载/" data-id="ck1u55jur000374tdhiwmf4az" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JVM 加载连接初始化简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/15/JVM 加载连接初始化简介/" class="article-date">
  <time datetime="2019-10-15T11:41:18.000Z" itemprop="datePublished">2019-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/15/JVM 加载连接初始化简介/">jvm加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>part 1</strong>介绍JVM的三个功能: 加载 连接 初始化</p>
<p><strong>虚拟机与程序的生命周期</strong></p>
<p>1.System.exit()</p>
<p>2.程序正常结束</p>
<p>3.程序抛出异常</p>
<p>4.操作系统让虚拟机结束</p>
<p><strong>1.加载</strong></p>
<p>查找并加载二进制流进内存，也就是进虚拟机</p>
<p>二进制文件包括</p>
<ol>
<li><p>从ZIP包中读取，最终成为JAR, EAR, WAR等格式</p>
</li>
<li><p>从网络中获取，Applet</p>
</li>
<li><p>运行时计算生成 动态代理技术</p>
</li>
<li><p>从其他文件中获取， jsp</p>
</li>
<li><p>从数据库中获取</p>
</li>
</ol>
<p><strong>细节</strong></p>
<p>1.通过一个类的全限定名Binary name来获取定义的二进制字节流</p>
<p>2.这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>3.在java堆中生成一个代表这个类的java.lang.Class对象,作为对方法区这些数据的访问入口</p>
<p>tip：这个阶段是可控性最强的阶段，可以使用自定义的类加载器来加载类。</p>
<p><strong>2.连接</strong></p>
<p>*.验证：验证二进制流的语法，确保二进制流的正确性，因为编译后的class文件，可能被恶意串改。</p>
<p>*.准备：为类的静态变量创建内存空间，并赋予初始值</p>
<p>*.解析:   把类的符号引用转为直接引用</p>
<p><strong>准备</strong></p>
<p>准备阶段是正式为类变量赋予内存空间和初始值，这些内存都在方法区中分配</p>
<ol>
<li>仅对类变量赋初始值即static修饰的变量，不包含实例变量，实例变量会在对象实例化一起被分配到java堆中</li>
</ol>
<p>public static int a = 2; 在准备阶段 a 被赋值为0而不是2；把a赋值为2的动作将在初始化阶段才会执行</p>
<ol start="2">
<li>如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值</li>
</ol>
<p><strong>初始化</strong></p>
<p>只有对类的首次主动使用才会触发类的初始化，7种主动使用的例子</p>
<ol>
<li>创建类的实例</li>
<li>主动调用类的静态方法</li>
<li>初始化类的子类，此类也算出次使用</li>
<li>访问类的静态变量 给静态变量赋值</li>
<li>发射Class.forName(“com.test.Test”)</li>
<li>被虚拟机启动时被标记为启动类</li>
<li>动态代理</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/15/JVM 加载连接初始化简介/" data-id="ck1u55jud000074tdnfy9zzx0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jvm笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/jvm笔记/" class="article-date">
  <time datetime="2019-07-08T02:09:39.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/jvm笔记/">jvm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对象在eden中产生，垃圾收集的过程中会让存活下的对象放在survivor区域，长期存活放在老年代区里</p>
<p><strong>Sun Classic VM</strong></p>
<ol>
<li><p>世界上第一个商用java虚拟机</p>
</li>
<li><p>只能使用纯解释器的方式执行java代码</p>
</li>
</ol>
<p><strong>Exact VM</strong></p>
<p><strong>HotSpot VM</strong></p>
<ol>
<li><p>hotSpot的历史</p>
</li>
<li><p>优势</p>
</li>
<li><p>称霸 开源</p>
</li>
</ol>
<p><strong>java内存区域</strong></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g4sa8n37zpj30y90lcjtv.jpg" alt="java虚拟机内存管理"></p>
<p>堆内存 = Java堆 栈内存=虚拟机栈的局部变量表</p>
<p><strong>程序计数器</strong></p>
<ol>
<li>程序计数器是一块较小的内存空间，可以看成当前的program counter是当前线程所执行的字节码的行号指示器。</li>
<li>是属于线程独占</li>
<li>如果是线程执行java方法，计数器记录的是正在执行的虚拟机字节码指令的地址,如果是native方法这个计数器的值为undefined</li>
<li>此区域唯一一个在java虚拟机中没有规定任何outofmemory的区域</li>
</ol>
<p><strong>java虚拟机栈</strong></p>
<ol>
<li>栈帧 每个方法执行，都会创建一个栈帧，伴随方法从创建到执行完成，用于存储局部变量表，操作数栈，动态链接，方法出口等。</li>
<li>局部变量表，存放编译期可知的各种变量类型。</li>
<li>大小 Stack Overflow outofmemory</li>
</ol>
<p><strong>本地方法栈</strong></p>
<p>本地方法栈为了虚拟机提供native方法服务</p>
<p>虚拟机栈为了虚拟机提供java方法服务</p>
<p><strong>java堆 线程共享</strong></p>
<p>存放对象实例</p>
<p>垃圾收集器管理的主要区域</p>
<p>新生代 老生代 Eden空间</p>
<p>outofmemory</p>
<p>-Xmx -Xms</p>
<p><strong>方法区 线程共享</strong></p>
<p>存储虚拟机加载的类信息，常量，静态变量，即时编译后的代码等</p>
<p>类的版本</p>
<p>字段</p>
<p>方法</p>
<p>接口</p>
<p>方法区 !=永久代</p>
<p>outofmemory</p>
<p><strong>判断对象是否可回收</strong></p>
<ol>
<li><p>计数算法：有指针引用+1, 指针为空就-1 但是有个问题无法解决，就是可回收对象的相互引用使得此对象们无法被回收</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g4tek1vc7oj30u00u0avo.jpg" alt="计数法"></p>
</li>
</ol>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object instance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Demo a = <span class="keyword">new</span> Demo();</span><br><span class="line">    Demo b = <span class="keyword">new</span> Demo();</span><br><span class="line">    </span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line">    </span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可达性分析</strong></p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4tfkp7zebj31400u0woz.jpg" alt="可达性分析"></p>
<p>没有被gcroot引用到的对象就是可回收    这里的指针root叫GCRoot. GCRoot如何被定义 作为gcroot的对象</p>
<ol>
<li>虚拟机栈 局部变量表</li>
<li>方法区的类属性所引用的对象</li>
<li>方法区中常量所引用的对象</li>
<li>本地方法栈所以引用的对象</li>
</ol>
<p><strong>垃圾回收算法</strong></p>
<p>标记清除算法</p>
<p>先标记（如何查找通过上述两个方法）后清除</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4tx877rj3j31aq0u0gmm.jpg" alt="标记"></p>
<p>效率很慢 因为要做2遍 一遍标记 一遍清除， 空间效率低 因为都是分散开来了，如果大的对象无法进入一些 hole。 所以我们需要清理的过程中整理java堆。</p>
<p><strong>复制算法</strong></p>
<p>堆</p>
<ol>
<li>新生代 Eden survior </li>
<li>老年代  Tenured</li>
</ol>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4uu5pxmexj31l40tu0tc.jpg" alt="复制算法"></p>
<p>分为2片区域， 如果一片区域完成后，需要保留的放到下一块，（排列好）</p>
<p>缺点 内存利用率不高</p>
<p>实际上， 我们将新生代（不同的内存情况，按不同的算法）将内存分为3块，1块Eden（80%）, 2块survivor （20% 一块10%）， 每次使用1 Eden 和 1 survior， 每次回收时，将保留下的对象，放到另一块survior上， 如果超过百分之10，需要内存担保 缺点 对于对象留存率很高的区域不适合，比如老年区</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g4uv6u0864j31ce0u00sx.jpg" alt="eden survior"></p>
<p><strong>标记整理算法</strong> 老年区</p>
<p>不直接进行对对象进行清理，而是让存活对象往一边靠拢，then直接清除边界以外的内存。</p>
<p><strong>分代收集算法</strong></p>
<p>根据对象存活周期不同划分不同的内存区域，java堆分为新生代，老年代，在新生代，用复制算法，在老年代用标记-整理算法</p>
<p><strong>垃圾收集器</strong></p>
<p>1.serial 收集器 ： 用一个CPU或者一个收集线程来收集垃圾，并且在它运行的时候，必须暂停其他线程，直到收集垃圾结束</p>
<p>2.parnew收集器：在垃圾收集过程中使用多线程去做， tradeoff ：大的更快，小的内存比serial慢。</p>
<p>3.parallel Scavenge收集器：cms收集器，想要的是减少用户收集垃圾时的等待时间，而ps 达到可控制的吞吐量， 吞吐量 = 代码运行时间/（代码运行时间 + 垃圾收集时间）</p>
<p>4.ps的可控制的吞吐量体现在2个参数： -XX:MaxGCPauseMillis -XX:GCTimeRatio</p>
<p>MaxGCPauseMillis：参数的值设定为一个大于0的值，收集器<strong>尽量</strong>吧垃圾收集的时间不超过设定值。 GC停顿时间是通过牺牲新生代内存+吞吐量换来的。</p>
<p>系统吧新生代调小一点，导致垃圾收集的频率提高，原来10秒1次现在5秒一次，停顿时间小了，但是吞吐量变小了。</p>
<p>GCTimeRatio 参数的值在 （0， 100）之间，也就是垃圾收集时间占时间的比例，</p>
<p><strong>CMS收集器</strong></p>
<p>CMS Concurrent Mark Sweep 收集器是一种以获取最短停顿时间为目标的收集器。B/S系统重视系统响应速度，希望系统停顿时间变短。</p>
<p>4步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ol>
<p>初始标记+重新标记 需要”stop the world”, 初始标记，标记GC root能直接关联到的对象， 并发标记：GC roots tracking. 重新标记（补偿）为了修正并发标记期间因用户程序而继续运作而产生变动的对象标记记录，T2 &gt; T3&gt;T1</p>
<p>因为大部分的时间花在了 并发标记+并发清除 这些时间都是可以和用户线程一起并发执行的</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g4w7t1iwrcj31580ju3yy.jpg" alt="cms"></p>
<p>CMS缺点</p>
<ol>
<li><p>CMS收集器对CPU资源非常敏感，面向并发设计的程序对CPU资源比交敏感，在并发阶段，不会让用户停顿但是会占有CPU资源导致应用变慢，总吞吐量变低， CPU数量+3 /4是cms默认配置，也就是在CPU在4个以上，并发回收线程不少于25%，并随着cpu数量的增加而下降。当CPU少了的会对用户程序影响越大。</p>
</li>
<li><p>cms收集器无法处理浮动垃圾， 可能出现“Concurrent Mode Failure”失败而导致Full GC产生，在并发清理的过程中，用户线程还在运行，所以产生的垃圾出现在标记过程之后，要等下一次才能处理掉她，所以为了这一部分，需要预留足够的内存给用户线程使用，所以cms无法像别的收集器一样在老年代几乎满了在收集垃圾，需要</p>
</li>
<li><p>mark-sweep的问题 出现大量的空间碎片</p>
<p><strong>G1 收集器</strong></p>
<p>G1 是一款面向服务服务端应用的垃圾收集器。</p>
<ol>
<li>并行与并发：服务端的 所以多在这个环境下能很厉害</li>
<li>分代收集：不同的方式处理新建的对象和存活很久的旧对象</li>
<li>空间整合：整体的标记整理算法 regin之间是复制算法</li>
<li>可预测的停顿：可建立停顿时间模型，让使用者明确在一个长度为M的上，不能让垃圾收集的时间超过N, 几乎实现Java RTSJ的垃圾收集器特证</li>
</ol>
<p>在G1收集器中， Region之间的对象以及其他收集器的新生代与老年代的对象引用，虚拟机都是有Remember Set来避免全堆扫描，G1中每个region都有一个remember set ，虚拟机在对reference数据进行写入操作时，会产生，writer barrier暂时中断写入操作， 检查reference引用对象是否处于不同的region中，如果是，便通过cardTable把相关索引信息记录到被引用对象所属的region的remember set中，当内存回收时，在GC根节点的枚举范围中加入Remember Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>初始标记 GC ROOT 直接关联到的对象 停顿线程但是并发</p>
<p>并发标记 gcroot到堆中对象可达性分析，毫无影响</p>
<p>最终标记 因用户导致标记产生变动放入 remember set中 停顿线程但是<strong>并行</strong>执行</p>
<p>筛选回收 根据用户期望来指定回收计划，停顿线程 （可以并发 但是停顿线程提高收集垃圾的效率）</p>
</li>
</ol>
<p><strong>GC日志</strong></p>
<p>32.125 ： [GC [DefNew： 3324k-&gt;152k(3712k),  0.0025925 sec] 3324k -&gt;152k(11904k), 0.003680 secs]</p>
<p>时间： 32.125</p>
<p>DefNew： 新生代</p>
<p>3324k -&gt; 152k(3712k) GC前该内存区域已使用容量-&gt;GC后该内存区域已使用的容量（该内存区域总容量）</p>
<p>3324k -&gt;152k(11904k) GC java堆使用情况（前）GC java堆使用情况（后）</p>
<p> 0.003680 secs GC 所需要时间</p>
<p><strong>动态对象年龄判定</strong></p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远要求对象的年龄必须达到的MaxTenuringThreshold才能晋升老年代</p>
<p>如果survior空间相同年龄的所有对象大于Survior空间的一半，大于或者等于该年纪的对象直接进入老年代。</p>
<p><strong>类加载</strong></p>
<p>在java代码中，类型的（class）加载， 连接与初始化过程都是在程序运行期间完成的。</p>
<p>提供了更大的灵活性，增加了更多的可能</p>
<p><strong>虚拟机与程序的生命周期</strong></p>
<p>4种情况结束</p>
<ol>
<li>System.exit()</li>
<li>程序正常运行结束</li>
<li>程序抛出异常</li>
<li>操作系统让虚拟机结束</li>
</ol>
<p><strong>类的加载，连接 初始化</strong></p>
<p>加载：查找并加载二进制流进内存 也就是进虚拟机</p>
<p>连接：</p>
<ol>
<li>验证：验证二进制流的语法，确保二进制流的正确性，接下来的都是检验别的</li>
<li>准备：为类的静态变量创建内存空间，并赋予初始值</li>
<li>解析：把类的符号引用转为直接引用</li>
</ol>
<p>初始化： 初始化对象的静态变量，赋予正确的初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此时经过初始化 a才是 = 1， 准备阶段是等于 0.</p>
<p>Java的类分为两种使用情况</p>
<ol>
<li>主动使用</li>
<li>被动使用</li>
</ol>
<p>虚拟机只有在<strong>首次且主动使用</strong>某个类或者接口时才会触发初始化</p>
<p>虚拟机定义了几种主动使用虚拟机的情况</p>
<ol>
<li>创建类的实例</li>
<li>调用类的静态方法</li>
<li>访问类的静态变量，或者给类的静态变量赋值</li>
<li>初始化该类的子类，此类也会被认为主动使用</li>
<li>放射 如 Class.forName(“com.test.Test1”)</li>
<li>被虚拟机启动时标为启动类</li>
<li>动态代理</li>
</ol>
<p>其他的情况都属于对类的被动使用，都不会对的类进行初始化</p>
<p>类的加载</p>
<p>把类的.class文件的二进制数据放入内存当中，放入运行时的方法区中，线程共享，</p>
<p>并创建一个java。lang。class对象放入方法区中，用来当做类的数据结构。</p>
<p>jvm设置参数</p>
<p>-XX: 这个是开头都不会变</p>
<ol>
<li>-XX:+<option> 开启option选项 是个boolean</option></li>
<li>-XX:-<option> 关闭option选项</option></li>
<li>-XX:<option>=<value>给option选项赋值值为value</value></option></li>
</ol>
<p>对于 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(MyParent2.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str = <span class="string">"Myparent2"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"initial myparent2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不会触发MyParent2的初始化，因为final 常量会在编译期把常量放入调用此类的常量池中。</p>
<p>对于编译期无法确定的值，我们会初始化这个类，无法把这个值放入使用类的常量池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Demo1.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String str = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Demo1 initial"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化和准备阶段：</p>
<p>在准备阶段会给各个field赋默认值，真因为有默认值所以才会不用初始化也可以使用这个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"count1 "</span> + singleton.count1);</span><br><span class="line">        System.out.println(<span class="string">"count2 "</span> + singleton.count2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">        System.out.println(count1);</span><br><span class="line">        System.out.println(count2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里count2可以先使用，在初始化0，因为我们先有了准备阶段。</p>
<p>加载：把java字节码 （class文件） 二进制文件读入java虚拟机中，内存当中</p>
<p>连接： 验证： class文件的语法错误</p>
<p>​            准备：为类的静态变量分配内存，设置默认值，但是在初始化前，类的静态变量没被真正初始化，</p>
<p>​            解析：常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程</p>
<p>初始化：类的静态变量的初始化</p>
<p>类实例化：</p>
<p>为新的对象分配内存</p>
<p>为实例变量赋予默认值</p>
<p>为实例变量赋予真的初始值</p>
<p>java编译器为它编译的每一个类都至少生成一个实例初始化方法，在java的class文件中，这个实例初始化方法被称为<init></init></p>
<p>方法，针对源码的构造方法，编译器都会产生一个<init>方法</init></p>
<p>类初始化的时机：</p>
<p>主动使用：</p>
<p>1.创建类的实例</p>
<p>2.访问某个类的或者接口的静态变量，或者对该静态变量赋值</p>
<p>3.调用类的静态方法</p>
<p>4.反射</p>
<p>5.初始化一个类的子类</p>
<p>6.java虚拟机启动时标记为启动类的类</p>
<p>7.动态语言</p>
<p>java虚拟机再初始化一个类时 要求他的所有父类已经被初始化，但是对于接口这条规则不适用</p>
<p>1.在初始化一个类时 不会初始化他所实现的接口</p>
<ol start="2">
<li><p>在初始化一个接口时 不会初始化这个接口的父接口</p>
<p>总结： 只有一个父接口不会因为他的子接口和他的实现类被初始化而初始化， 只有调用接口的静态变量</p>
</li>
</ol>
<p><strong>类加载器</strong></p>
<p>我们定义的类通常由appclassLoader进行加载的</p>
<p>string 等 rt.jar 根类加载器</p>
<p>结论：根有根的class 需要去加载 比如string， 系统类加载器有系统类的加载的类，我们自定义的类加载器有我们需要加载的， 我们会自上而下的去寻找是否被加载，从当前类加载器开始，首先他会自己检测自己有没有加载这个类，如果没有，望向上的类加载器去检查，是否自己加载了，如果最顶端的检查完没有加载过，向下开始尝试加载。</p>
<p><strong>类的卸载</strong></p>
<p>当MySample类被加载，连接和初始化后，他的生命周期就开始了，当代表mysammple类的class对象不再被引用，及不可触及时，class对象就会结束生命周期， mysample类在方法区内的数据也会被被卸载，从而结束mysample类的生命周期</p>
<p>一个类合适结束生命周期，取决于代表它的class对象何时结束生命周期</p>
<p><strong><em>命名空间</em></strong></p>
<p>1子加载器加载的类可以访问父加载器加载的类，而父加载器加载的类访问不了子加载器加载的类</p>
<p>命名空间是由 当前加载器和其父加载器构成的，其中的类不能重复</p>
<p>内建于jvm虚拟机内部的启动类加载器会加载java.lang.classLoader等加载器，在jvm启动时，jvm内的一部分特殊代码块会启动，他会加载扩展类加载器和系统类加载器， 他就是启动类加载器 bootstrap</p>
<p>启动类加载器不是java类，他是jvm的（系统像特定）机器指令，启动类加载器负责开启整个加载过程。</p>
<p>启动类加载器还负责jre工作的模块 比如java.util java.lang.string</p>
<p><strong><em>上下文加载器</em></strong></p>
<p>当前类加载器 Current ClassLoader</p>
<p>每个类都会使用自己的类加载器 加载自身的加载器去加载其他类，</p>
<p>如果CLASS X 引用了class y 那么 class x用加载自己的类加载器去加载class y 如果y没有被加载</p>
<p>线程上下文加载器 从JDK 1.2 开始， 类Thread.currentThread().getContextClassLoader()</p>
<p>如果没有通过set 和 get 方法进行设置， 线程将继承父线程的上下文加载器</p>
<p>java运行的初始线程的上下文加载器都是系统类加载器， 在线程运行的代码可以通过该类加载器加载类与资源</p>
<p>SPI(Service Provider Interface)</p>
<p>父classLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的classLoader加载的类。这就改变了父classLoader不能使用子classLoader或者其他没有父子关系的classLoader加载类的情况，即改变了双亲委派模型</p>
<p>线程上下文加载器就是当前线程的Current ClassLoader</p>
<p>在双亲委托模型下，类加载从下至上的，下层的类加载器会委托上层的类加载器去加载，但在spi来说，有些接口时java核心库所提供的，而java核心库是用启动类加载器所提供的，而这些接口的实现去来自不同的jar包 厂商提共的， java的启动类加载器不会加载其他来源的jar包， 这些传统的双清委托模型无法满足spi要求，而这些可以同给当前线程设置上下文类加载器就可以由上下文类加载器来实现对于接口实现类的加载。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/jvm笔记/" data-id="ck1u55juu000474tdeqpq8bga" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-markdown-语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/markdown-语法/" class="article-date">
  <time datetime="2019-06-13T11:38:19.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/markdown-语法/">markdown 语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="markdown语法介绍"><a href="#markdown语法介绍" class="headerlink" title="markdown语法介绍"></a>markdown语法介绍</h1><p>markdown是一种轻量级标记语言，让语言有了格式，但是规则很简单，我带大家简单看一些markdown的语法规则</p>
<h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><p>如果你想给文本上增加标题样式，可以再标题前面加 “<strong>#</strong>“即可，markdown共支持六级标题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br><span class="line"><span class="comment">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<p>效果图</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 标题</span><br></pre></td></tr></table></figure>

<p>会被解析成html语法中的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 id = <span class="string">"user-content-标题"</span>&gt;标题&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>其中你会发现 其实markdown给这个标题添加了个id且前缀为 user-content-</p>
<p><strong>引用</strong></p>
<p>在文本前面添加 <strong>&gt;</strong>实现引用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是个引用</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<blockquote>
<p>这是个引用</p>
</blockquote>
<p>可以多级引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; 三级引用</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line">&gt;</span><br><span class="line">&gt; 引用</span><br></pre></td></tr></table></figure>

<p>引用可以配合其他一起使用，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 标题</span></span><br></pre></td></tr></table></figure>

<p>效果图</p>
<blockquote>
<h1 id="标题-1"><a href="#标题-1" class="headerlink" title="标题"></a>标题</h1></blockquote>
<p><strong>列表</strong></p>
<p>无序列表：使用星号，加好或者减号作为列表标记</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Red</span><br><span class="line">- Yellow</span><br><span class="line">- Blue</span><br></pre></td></tr></table></figure>

<ul>
<li>Red</li>
<li>Yellow</li>
<li>Blue</li>
</ul>
<p>有序列表：使用数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Red</span><br><span class="line">2. Yellow</span><br><span class="line">3. Blue</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<ol>
<li>Red</li>
<li>Yellow</li>
<li>Blue</li>
</ol>
<p>代办列表：表示列表是否勾选</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 不勾选</span><br><span class="line">- [x] 勾选</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<ul>
<li><input disabled type="checkbox"> <p>不勾选</p>
</li>
<li><input checked disabled type="checkbox"> <p>勾选</p>
</li>
</ul>
<p><strong>代码</strong></p>
<p>只要把你的代码包裹在”` 就可以了， 也可以用 ”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```bash</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><strong>连接</strong></p>
<p>方括号是名字，圆括号是网址，markdown会识别他为链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[欢迎我的网站www.martinpl.top](http://www.martinpl.top)</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><a href="http://www.martinpl.top" target="_blank" rel="noopener">欢迎我的网站www.martinpl.top</a></p>
<p><strong>表格</strong></p>
<p>表格的语法是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Head1 | head2 | head3</span><br><span class="line">----- | ----- | -----</span><br><span class="line">c1    | c2    | c3</span><br><span class="line">c4    | c5    | c6</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<table>
<thead>
<tr>
<th>Head1</th>
<th>head2</th>
<th>head3</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>c2</td>
<td>c3</td>
</tr>
<tr>
<td>c4</td>
<td>c5</td>
<td>c6</td>
</tr>
</tbody></table>
<p>也可以使用让左边居左，中间居中，右边居右</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Head1 | head2 | head3</span><br><span class="line">:---- | :---: | ----:</span><br><span class="line">c1    | c2    | c3</span><br><span class="line">c4    | c5    | c6</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<table>
<thead>
<tr>
<th align="left">Head1</th>
<th align="center">head2</th>
<th align="right">head3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">c1</td>
<td align="center">c2</td>
<td align="right">c3</td>
</tr>
<tr>
<td align="left">c4</td>
<td align="center">c5</td>
<td align="right">c6</td>
</tr>
</tbody></table>
<p><strong>分割线</strong></p>
<p>在markdown中 使用 3个以上”-“符号制作分割线</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上分割内容</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">下分割内容</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p>上分割内容</p>
<hr>
<p>下分割内容</p>
<p><strong>图片</strong></p>
<p>Markdown 使用了类似链接的语法来插入图片, 包含两种形式: <strong>内联</strong> 和 <strong>引用</strong>.</p>
<p><strong>内联</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](/path/to/img.jpg)</span><br><span class="line">或</span><br><span class="line">![Alt text](/path/to/img.jpg <span class="string">"Optional title"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>引用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][id]</span><br></pre></td></tr></table></figure>

<p>Id 是图片引用的名称，图片引用使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: url/to/image <span class="string">"Optional title attribute"</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/13/markdown-语法/" data-id="ck1u55juz000574tdsf54i2l1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-如何搭建个人博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/09/如何搭建个人博客/" class="article-date">
  <time datetime="2019-06-09T15:10:42.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/如何搭建个人博客/">如何搭建个人博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1>简介</h1>
我将带领大家使用hexo(blog 框架)来搭建个人博客，并部署到github上并建立域名，让你们的博客可以被所有人看到。



<h1>步骤</h1>
1. 注册github，创建repository
2. 安装git
3. 安装hexo
4. 部署hexo到github上
5. 绑定域名

<h1>细节</h1>
**注册github, 创建repository**

<p>登录到github，如果没有注册github，点击右上角头像，点击注册, 然后点击+号下面的 new repository， 在这里的Repository的名字有要求,要求是 <strong>用户名</strong>.github.io</p>
<p><strong>用户名为github的账户名</strong> 比如我的</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u7cyz3ioj30oc0b0dgx.jpg" alt="githubprofilename"></p>
<p><strong>安装git</strong></p>
<p>git是一个分布式版本管理系统。其中github是基于git的代码管理平台，上面有无数的大神写的开源代码。大家可以参考廖雪峰老师的网站学习git，其中包括如何<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000" target="_blank">git安装</a> </p>
<p><strong>Linuxs上安装</strong></p>
<p>首先在终端(terminal)上输入: git </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program <span class="string">'git'</span> is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>可以参照命令<code>sudo apt-get install git</code>来进行安装。也可以直接下载git源码，解压，到达路径，依次输入 <code>./config</code> <code>make</code> 和<code>sudo make</code>进行安装。</p>
<p><strong>mac OX S上安装</strong></p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a>。</p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<p><strong>window上安装</strong></p>
<p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>（网速慢的同学请移步<a href="https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit" target="_blank" rel="noopener">国内镜像</a>），然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/919018718363424/0" alt="install-git-on-windows"></p>
<p>安装完成后，要做一些配置，在终端输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>
<p>生成ssh密钥文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<p>然后找到.ssh文件下的id_rsa.pub，打开它通过命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制里面的公钥添加到github下，打开<a href="https://github.com/settings/keys" target="_blank" rel="noopener">GitHub_Settings_keys</a> 页面，新建new SSH Key <img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3u79mbazoj30y20nata8.jpg" alt="添加sshkey"></p>
<p>将id_rsa.pub里的内容复制到key下面的文本里，title可以随便填</p>
<p>在终端里输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>

<p>如果结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi martinpl01! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">Connection to github.com closed.</span><br></pre></td></tr></table></figure>

<p>则代表成功</p>
<p><strong>安装hexo</strong></p>
<p>在安装hexo前，要配置hexo的环境，由于hexo基于node.js。所以先安装node.js还有npm(node package manager) npm是node.js的包管理工具, 大家可以参考廖雪峰老师的网站链接地址：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025597810528" target="_blank" rel="noopener">廖雪峰老师网站</a></p>
<p>安装完毕后新建文件夹为blog，在blog目录下</p>
<p>使用npm命令安装Hexo，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>Tips 在这里我遇到了个困难，弄了我一个小时，就是安装成功但是 输入 hexo -v来检查hexo 是否安装成功后显示 没有hexo指令，发现是环境配置不对，通过</p>
<p>export PATH=$PATH:/xxxxxx/bin</p>
<p>然后初始化我们的博客，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<p>然后通过输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>在浏览器输入地址 localhost:4000</p>
<p>你可以看到hexo为我们默认写的一篇blog</p>
<p><strong>部署hexo到github上</strong></p>
<p>我们的博客不能只放在自己的主机上，需要被更多的人访问到，那么我们需要把网站部署到github上。那么如何把hexo部署到github的账户上，需要把两者做关联，其实也就是把hexo的配置文件里加上github。</p>
<p>在blog的路径下，有个配置文件叫_config.yml文件称为<strong>站点</strong>配置文件。打开此文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/martinpl01/martinpl01.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>记得在：之后要空格</p>
<p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后我们运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即<a href="www.martinpl.top">martinpl01.github.io</a></p>
<p><strong>绑定域名</strong></p>
<p>通过阿里云的控制台，购买域名同时解析<img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3u708vlu1j31ri08240a.jpg" alt="域名"></p>
<p>然后登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名如<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3u7geikcyj313m07ijsc.jpg" alt="域名"></p>
<p>然后输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>这样就可以看到通过访问自己的域名来浏览自己的blog啦</p>
<p>我的路径是 /Documents/blog/blog 然后 输入</p>
<p>hexo clean</p>
<p>hexo g -d</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/09/如何搭建个人博客/" data-id="ck1u55jv2000874tdkf1icbr2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/09/hello-world/" class="article-date">
  <time datetime="2019-06-09T09:09:38.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/09/hello-world/" data-id="ck1u55juj000174tdacxtam3q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/学习/" style="font-size: 10px;">学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/16/JVM加载/">JVM加载</a>
          </li>
        
          <li>
            <a href="/2019/10/15/JVM 加载连接初始化简介/">jvm加载</a>
          </li>
        
          <li>
            <a href="/2019/07/08/jvm笔记/">jvm</a>
          </li>
        
          <li>
            <a href="/2019/06/13/markdown-语法/">markdown 语法</a>
          </li>
        
          <li>
            <a href="/2019/06/09/如何搭建个人博客/">如何搭建个人博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>